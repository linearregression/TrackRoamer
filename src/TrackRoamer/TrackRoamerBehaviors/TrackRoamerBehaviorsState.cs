//------------------------------------------------------------------------------
// TrackRoamerBehaviorsTypes.cs
//
//     This code was generated by the DssNewService tool.
//
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.ComponentModel;

using Microsoft.Ccr.Core;
using Microsoft.Dss.ServiceModel.Dssp;
using Microsoft.Dss.Core.Attributes;
using dssp = Microsoft.Dss.ServiceModel.Dssp;
using Microsoft.Dss.Core.DsspHttp;
using W3C.Soap;

using TrackRoamer.Robotics.LibMapping;
using TrackRoamer.Robotics.LibBehavior;

using bumper = Microsoft.Robotics.Services.ContactSensor.Proxy;
using drive = Microsoft.Robotics.Services.Drive.Proxy;
using sicklrf = Microsoft.Robotics.Services.Sensors.SickLRF.Proxy;
using encoder = Microsoft.Robotics.Services.Encoder.Proxy;
using proxibrick = TrackRoamer.Robotics.Services.TrackRoamerBrickProximityBoard.Proxy;
using trackroamerbehaviors = TrackRoamer.Robotics.Services.TrackRoamerBehaviors;

namespace TrackRoamer.Robotics.Services.TrackRoamerBehaviors
{
    /// <summary>
    /// Track Roamer Behaviors State
    /// </summary>
    [DataContract()]
    public class TrackRoamerBehaviorsState
    {
        public TrackRoamerBehaviorsState()
        {
            Init();
        }

        public void Init()
        {
            Dropping = false;

            IsTurning = false;
            LastTurnStarted = DateTime.MinValue;
            LastTurnCompleted = DateTime.MinValue;

            if (WheelsEncoderState == null)
            {
                WheelsEncoderState = new WheelsEncoderState();
            }

            if (collisionState == null)
            {
                collisionState = new CollisionState();
            }

            if (gpsState == null)
            {
                gpsState = new GpsState();
            }

            if (MostRecentAnalogValues == null)
            {
                MostRecentAnalogValues = new proxibrick.AnalogDataDssSerializable() { TimeStamp = DateTime.MinValue };
            }

            MostRecentLaserTimeStamp = DateTime.Now;

            if (VoiceCommandState == null)
            {
                VoiceCommandState = new VoiceCommandState();
            }

            int MAX_HUMANS_TO_TRACK = 7;    // FrameProcessor preallocates 7 

            HumanInteractionStates = new HumanInteractionState[MAX_HUMANS_TO_TRACK];

            for (int i = 0; i < HumanInteractionStates.Length; i++)
            {
                HumanInteractionStates[i] = new HumanInteractionState();
            }

            if (followDirectionPidControllerAngularSpeed == null)
            {
                followDirectionPidControllerAngularSpeed = new PIDController()
                    {
                        Name = "AngularSpeed",
                        MaxIntegralError = 180.0d,          // degrees; anything more causes controller reset (error too large)
                        MaxUpdateIntervalSec = 10.0d,       // ms; anything more causes controller reset (interval too long)
                        MaxPidValue = 100.0d,               // pid factor upper limit
                        MinPidValue = 0.0d,                 // pid factor lower limit

                        Kp = PIDController.ProportionalGainDefault,             // Proportional constant, 3.0
                        Ki = PIDController.IntegralGainDefault,                 // Integral constant, 0.1
                        Kd = PIDController.DerivativeGainDefault                // Derivative constant, 0.5
                    };
            }

            if (followDirectionPidControllerLinearSpeed == null)
            {
                followDirectionPidControllerLinearSpeed = new PIDController()
                    {
                        Name = "LinearSpeed",
                        MaxIntegralError = 2000.0d,         // mm/sec; anything more causes controller reset (error too large)
                        MaxUpdateIntervalSec = 10.0d,       // ms; anything more causes controller reset (interval too long)
                        MaxPidValue = 1000.0d,              // pid factor upper limit
                        MinPidValue = 0.0d,                 // pid factor lower limit

                        Kp = PIDController.ProportionalGainDefault,             // Proportional constant, 3.0
                        Ki = PIDController.IntegralGainDefault,                 // Integral constant, 0.1
                        Kd = PIDController.DerivativeGainDefault                // Derivative constant, 0.5
                    };
            }

            if (PowerScale == 0.0d)
            {
                PowerScale = 0.5d;
            }
        }

        #region data members

        [DataMember(IsRequired = false)]
		public drive.DriveDifferentialTwoWheelState DriveState { get; set; }

		//[DataMember(IsRequired = false)]
        //public encoder.EncoderState EncoderStateLeft { get; set; }

		//[DataMember(IsRequired = false)]
        //public encoder.EncoderState EncoderStateRight { get; set; }

        [DataMember]
        public WheelsEncoderState WheelsEncoderState { get; set; }

        [DataMember]
        public bool IsTurning { get; set; }

		[DataMember]
        public DateTime LastTurnStarted { get; set; }

        [DataMember]
        public DateTime LastTurnCompleted { get; set; }

		[DataMember]
		public int Countdown { get; set; }

        [Browsable(false)]
        [DataMember]
        public bool Dropping { get; set; }

        [DataMember]
        public MovingState MovingState { get; set; }

        [DataMember]
        public string MovingStateDetail { get; set; }

		[DataMember]
		public int NewHeading { get; set; }

		[DataMember]
        public double Velocity { get; set; }           // the vehicle velocity in m/s

		[DataMember]
		public sicklrf.State South { get; set; }

		[DataMember]
		public bool Mapped { get; set; }

		[DataMember]
		public DateTime MostRecentLaserTimeStamp { get; set; }

		[DataMember]
        public HumanInteractionState[] HumanInteractionStates { get; set; }

        // Speech Recognizer Command related (only recognized and accepted commands make it here):
		[DataMember]
        public VoiceCommandState VoiceCommandState { get; set; }

        // these sound direction values have not passed Voice Command recognition criteria, but were registered:
        [DataMember]
        public int SoundBeamDirection { get; set; }

        [DataMember]
        public DateTime SoundBeamTimeStamp { get; set; }

        [DataMember]
        public int AnySpeechDirection { get; set; }

        [DataMember]
        public DateTime AnySpeechTimeStamp { get; set; }

        // data coming from Proximity Board:

        /// <summary>
        /// Last compass reading.
        /// </summary>
        [DataMember, Browsable(true)]
        public proxibrick.DirectionDataDssSerializable MostRecentDirection { get; set; }

        /// <summary>
        /// Last Accelerometer reading.
        /// </summary>
        [DataMember, Browsable(true)]
        public proxibrick.AccelerometerDataDssSerializable MostRecentAccelerometer { get; set; }

        /// <summary>
        /// Last IR Directed (Proximity) sensors reading.
        /// </summary>
        [DataMember, Browsable(true)]
        public proxibrick.ProximityDataDssSerializable MostRecentProximity { get; set; }

        /// <summary>
        /// Last whiskers reading.
        /// </summary>
        [DataMember, Browsable(true)]
        public bool MostRecentWhiskerLeft { get; set; }
        [DataMember, Browsable(true)]
        public bool MostRecentWhiskerRight { get; set; }

        /// <summary>
        /// Last Parking Sensors reading.
        /// </summary>
        [DataMember, Browsable(true)]
        public proxibrick.ParkingSensorDataDssSerializable MostRecentParkingSensor { get; set; }

        /// <summary>
        /// Last Pot (pin 2 AN0 of PIC 4550) and other analog data reading.
        /// </summary>
        [DataMember, Browsable(true)]
        public proxibrick.AnalogDataDssSerializable MostRecentAnalogValues { get; set; }

        [DataMember, Browsable(true)]
        public double currentTiltKinect = 0.0d;     // Degrees, upwards positive
        [DataMember, Browsable(true)]
        public double currentPanKinect = 0.0d;      // Degrees, right positive

        [DataMember, Browsable(true)]
        public CollisionState collisionState;       // compute it in computeCollisionState(), do not replace

        [DataMember, Browsable(true)]
        public GpsState gpsState;

        [DataMember, Browsable(true)]
        public PIDController followDirectionPidControllerAngularSpeed;

        [DataMember, Browsable(true)]
        public PIDController followDirectionPidControllerLinearSpeed;

        [DataMember, Browsable(true)]
        public double PowerScale;               // all above power and speed are multiplied by PowerScale
                                                // also see MotorPowerScalingFactor=100 in the TrackRoamerDriveTypes.cs

        #endregion

		#region internal helper accessors for meta states - IsMapping, IsUnknown, IsMoving, IsActive

#if OBSOLETE_PLANANDAVOID_LOGIC
        // robot is busy performing a part of mapping sequence
		internal bool IsMapping
		{
			get
			{
				return
                    MovingState == MovingState.RandomTurn ||
                    //MovingState == MovingState.MapNorth ||
                    //MovingState == MovingState.MapSouth ||
                    //MovingState == MovingState.MapSurroundings ||
                    MovingState == MovingState.Recovering;
			}
		}
#endif // OBSOLETE_PLANANDAVOID_LOGIC

        // robot is likely to use Decide() to figure out what to do next
		internal bool IsUnknown
		{
			get
			{
                return MovingState == MovingState.Unknown;
			}
		}

        // robot is doing something not in place (like mapping is an in-place sequence). 
        // all transitional sequences and backing up means it is moving too.
		internal bool IsMoving
		{
			get
			{
				return IsActive; // && !IsMapping;
			}
		}

        // robot is doing something, likely a step of some task
		internal bool IsActive
		{
			get
			{
				return !IsUnknown;
			}
		}
		#endregion
	}

    /// <summary>
    /// Speech Recognizer Command related (only recognized and accepted commands make it here):
    /// </summary>
    [DataContract()]
    public class VoiceCommandState
    {
        public VoiceCommandState()
        {
            TimeStamp = DateTime.MinValue;
        }

        [DataMember]
        public DateTime TimeStamp { get; set; }

        [DataMember]
        public string Text { get; set; }

        [DataMember]
        public string Semantics { get; set; }

        [DataMember]
        public int Direction { get; set; }

        [DataMember]
        public int ConfidencePercent { get; set; }
    }

    [DataContract()]
    public class HumanInteractionState
    {
        public HumanInteractionState()
        {
            TimeStamp = DateTime.MinValue;
        }

        [DataMember]
        public bool IsTracked { get; set; }

        /// <summary>
        /// a number maintained by Kinect. See  http://msdn.microsoft.com/en-us/library/jj131025.aspx#Active_User_Tracking
        /// </summary>
        [DataMember]
        public int TrackingId { get; set; }

        [DataMember]
        public bool IsMain { get; set; }

        [DataMember]
        public DateTime TimeStamp { get; set; }

        [DataMember]
        public double DirectionPan { get; set; }

        [DataMember]
        public double DirectionTilt { get; set; }

        [DataMember]
        public double DistanceMeters { get; set; }
    }

    [DataContract]
	public enum MovingState
	{
		Unknown,                // not doing anything, should begin planning next action based on situation. Typical after recovering.
        Unable,                 // cannot move where it wanted to, collision state prohibits executing current plan, no good secondary plans either.
        FreeForwards,           // rolling forwards, constantly adjusting wheels' speed (normally using PID controller and SetDrivePower)
        InTransition,           // performing a direct Differential Drive move, like a turn by degrees or Translate.

        //AdjustHeading,
        Recovering,
        LayingDown,

        // almost obsolete:
        BumpedBackingUp,
        //RandomTurn

        // obsolete:
        //MapSurroundings,
        //MapNorth,
        //MapSouth,
	}

    public enum SensorEventSource
    {
        Orientation,
        Compass,
        Gps,
        LaserScanning,
        SonarDirected,
        IrDirected,
        Bumper,
        Whiskers,
        Kinect
    }
}
