//------------------------------------------------------------------------------
// TrackRoamerMotor.cs
//
//     This code was generated by the DssNewService tool.
//
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Xml;
using xml = System.Xml;
using System.Net;

using Microsoft.Ccr.Core;
using Microsoft.Dss.Core;
using Microsoft.Dss.Core.Attributes;
using Microsoft.Dss.ServiceModel.Dssp;
using Microsoft.Dss.Core.DsspHttp;
using Microsoft.Dss.ServiceModel.DsspServiceBase;

using coord = Microsoft.Robotics.Services.Coordination.Proxy;

using pxmotor = Microsoft.Robotics.Services.Motor.Proxy;

using powerbrick = TrackRoamer.Robotics.Services.TrackRoamerBrickPower.Proxy;
using trackroamermotor = TrackRoamer.Robotics.Services.TrackRoamerServices.Motor;

using TrackRoamer.Robotics.Utility.LibSystem;

namespace TrackRoamer.Robotics.Services.TrackRoamerServices.Motor
{
    /// <summary>
    /// Track Roamer Motor Service
    /// </summary>
    [Contract(Contract.Identifier)]
    //[AlternateContract("http://schemas.microsoft.com/robotics/2006/05/motor.html")]
	[AlternateContract(pxmotor.Contract.Identifier)]
    [DisplayName("(User) TrackRoamer Motor")]
	[Description("Provides access to the TrackRoamer motor.\n(Uses the Generic Motor contract.)")]
	public class TrackRoamerMotorService : DsspServiceBase
    {
        // below MinimumMotorPower the wheels won't turn, therefore encoders won't tick and drive moves will have to timeout.
        // Speed 100 corresponds to Power 0.10d  - so the 0.01d power is Speed 10 mm/sec
        private const double MinimumMotorPower = 0.01d;

		[EmbeddedResource("TrackRoamer.Robotics.Services.TrackRoamerServices.TrackRoamerMotor.xslt")]
		string _transform = null;

		[InitialStatePartner(Optional = true)]
		private pxmotor.MotorState _state = new pxmotor.MotorState();

		[ServicePort("/trackroamermotor", AllowMultipleInstances=true)]
		private pxmotor.MotorOperations _mainPort = new pxmotor.MotorOperations();

        [Partner("TrackRoamerPowerBrick", Contract = powerbrick.Contract.Identifier, CreationPolicy = PartnerCreationPolicy.UseExistingOrCreate, Optional = false)]
        private powerbrick.TrackRoamerBrickPowerOperations _powerbrickPort = new powerbrick.TrackRoamerBrickPowerOperations();

        public TrackRoamerMotorService(DsspServiceCreationPort creationPort) : 
                base(creationPort)
        {
        }

		protected override void Start()
        {
			// call base Start() method that will activate operation handlers, log uri, insert to directory
			base.Start();

			// initialize default state.
            // we expect the drive to set actual state for us (in ReplaceHandler).
			if (_state == null)
			{
				_state = new pxmotor.MotorState();
				_state.PowerScalingFactor = 10.0d;      // actually will be percent, for example 40.0d
				_state.HardwareIdentifier = 1;			// 1=Left 2=Right
				_state.Name = "Left";
				_state.CurrentPower = 0.0;
			}
		}

        /// <summary>
        /// Get Handler
        /// </summary>
        /// <param name="get"></param>
        /// <returns></returns>
        [ServiceHandler(ServiceHandlerBehavior.Concurrent)]
        public virtual IEnumerator<ITask> GetHandler(pxmotor.Get get)
        {
            get.ResponsePort.Post(_state);
            yield break;
        }

		[ServiceHandler(ServiceHandlerBehavior.Concurrent)]
		public virtual IEnumerator<ITask> HttpGetHandler(HttpGet httpGet)
		{
			httpGet.ResponsePort.Post(new HttpResponseType(
				HttpStatusCode.OK,
				_state,
				_transform)
			);
			yield break;
		}

		/// <summary>
        /// Replace Handler
        /// </summary>
        /// <param name="replace"></param>
        /// <returns></returns>
        [ServiceHandler(ServiceHandlerBehavior.Exclusive)]
        public virtual IEnumerator<ITask> ReplaceHandler(pxmotor.Replace replace)
        {
            _state = replace.Body;
            replace.ResponsePort.Post(DefaultReplaceResponseType.Instance);
            yield break;
        }

        /// <summary>
        /// SetMotorPower Handler
        /// </summary>
        /// <param name="update"></param>
        /// <returns></returns>
        [ServiceHandler(ServiceHandlerBehavior.Exclusive)]
        public virtual IEnumerator<ITask> SetMotorPowerHandler(pxmotor.SetMotorPower update)
        {
			if (_state.HardwareIdentifier == 0)
			{
				throw new InvalidOperationException("TrackRoamer Motor configuration missing");
			}

			powerbrick.MotorSpeed motorSpeed = new powerbrick.MotorSpeed();

            // Default -1 which is ignored by the controller.
            motorSpeed.LeftSpeed = null;
            motorSpeed.RightSpeed = null;

			double power = update.Body.TargetPower * _state.PowerScalingFactor / 100.0d;		// PowerScalingFactor is percentage, 0 to 100

            if (power != 0.0d && Math.Abs(power) < MinimumMotorPower)
            {
                //string msg = string.Format("Warning: Motor {0} - requested power {1} less than minimum {2}", _state.HardwareIdentifier, power, MinimumMotorPower);
                //Tracer.Trace(msg);
                //LogWarning(msg);

                power = (power < 0) ? -MinimumMotorPower : MinimumMotorPower; 
            }

            //Tracer.Trace(string.Format("Motor {0} - setting power to {1}", _state.HardwareIdentifier, power));

			if (_state.HardwareIdentifier == 1)
			{
				motorSpeed.LeftSpeed = _state.ReversePolarity ? -power : power;
			}
			else if (_state.HardwareIdentifier == 2)
			{
				motorSpeed.RightSpeed = _state.ReversePolarity ? -power : power;
			}
			else
			{
				throw new ArgumentException("TrackRoamerMotorService : SetMotorPowerHandler() invalid HardwareIdentifier=" + _state.HardwareIdentifier);
			}

            _state.CurrentPower = power;

            coord.ActuatorCoordination coordination = update.GetHeader<coord.ActuatorCoordination>();
            if (coordination == null)
            {
				_powerbrickPort.UpdateMotorSpeed(motorSpeed);
            }
            else
            {
                // TODO: Remove this extra code when we allow headers 
                //       to flow with a causality across services.

				// Pass on the coordination to the trackroamerbot
				powerbrick.UpdateMotorSpeed updateMotorSpeed = new powerbrick.UpdateMotorSpeed(motorSpeed);
                updateMotorSpeed.AddHeader(coordination);
				_powerbrickPort.Post(updateMotorSpeed);
            }

            update.ResponsePort.Post(DefaultUpdateResponseType.Instance);
            yield break;
        }
    }
}
